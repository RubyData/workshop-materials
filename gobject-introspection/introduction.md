# GObject Introspection入門

## 背景

RubyにはC・C++で実装されたライブラリーの機能を使えるようにするための仕組みがあります。この仕組みを使うと既存の高速・高機能なライブラリーをRubyから利用できます。これによりRubyの書きやすさとC・C++の速度を組み合わせて開発することができます。

C・C++で実装されたライブラリーの機能をRubyから使えるようにしたRubyのライブラリーのことを「バインディング」と呼びます。

データサイエンスの分野ではC・C++で実装されたライブラリーが多くあります。大量のデータを現実的な時間で扱うために性能が必要になるからです。

まだRubyのライブラリーとして利用できない機能を、新しくRubyでも利用できるようにするアプローチは、主に以下の2つです。

  * 既存のC・C++のライブラリーのバインディングを実装する

  * 1からRubyで実装する

多くの場合、前者の方が実装コスト・性能面で有利です。

よって、C・C++で実装された既存の有用なライブラリーのバインディングを実装することは、データサイエンスの分野でRubyをより活用するための現実的な方法の1つです。

この文書では[GObject Introspection][gobject-introspeciton]を使ってバインディングを実装する方法を順を追って説明します。この文書の読者が以下の1つ以上の状態になることを目指します。

  * GObject Introspectionを使ってバインディングを実装できる

  * 既存のGObject Introspectionを使ったバインディングを改良・修正できる

なお、読者にはRubyの一般的な知識およびC・C++をなんとなく読める程度の知識があることを前提とします。

## GObject Introspectionと他のバインディング実装方法の違い

GObject IntrospectionはCで実装されたライブラリーのバインディングの実装を強力に支援するライブラリー・ツール群です。C++で実装されたライブラリーでもCでラップすることでGObject Introspectionを利用できます。実際、この文書では[OpenCV][opencv]というC++で実装されたコンピュータビジョン用のライブラリーのバインディングをGObject Introspectionを使って実現する方法を実例として使って説明します。

GObject Introspection自体は2005年に開発が始まったプロダクトです。つまり、10年以上継続的に改良が続いている安心して使えるプロダクトということです。類似のプロダクトに[SWIG][swig]があります。これは1995年から開発がはじまっているので20年以上継続的に改良が続いています。

バインディングを実装する主な方法は次の通りです。

  * Rubyが提供するC APIを利用して、Cでバインディングを実装する

  * [Fiddle][fiddle]を利用して、Rubyでバインディングを実装する

  * SWIGを利用して、Cで実装されたバインディングを自動生成する

  * GObject Introspectionを利用して、実行時にバインディングを自動生成する

単純なCのライブラリーであれば、最初の2つの方法（CまたはRubyでバインディングを実装する方法）が現実的です。そうでない場合は最後の2つの方法（SWIGまたはGObject Introspectionを利用する方法）も検討します。

たとえば、OpenCVは1000以上の関数を提供している複雑なライブラリーなので、最後の2つの方法の採用も検討します。

実際のどの方法を採用するかを判断できるようになるために、それぞれの方法の違いを説明します。

### Rubyが提供するC APIを利用して、Cでバインディングを実装する

まず、「Rubyが提供するC APIを利用して、Cでバインディングを実装する」方法について説明します。

RubyはCでRubyのライブラリーを実装する仕組みを提供しています。この仕組みを使って実装したライブラリーを「拡張ライブラリー」と呼びます。拡張ライブラリーを実装するためにRubyはC APIを提供しています。

Rubyが提供しているC APIには、たとえば、Cの文字列（`char *`）をRubyの文字列（`String`オブジェクト）にする`rb_str_new()`やクラスを定義する`rb_define_class()`などがあります。つまり、Rubyで書いているような処理をCでも書けるということです。

RubyのC APIを使うと、C・C++で実装された既存のライブラリーとRubyの橋渡し部分をCで実装できます。この橋渡し部分を「バインディング」というので、Cでバインディングを書けるということです。

たとえば、疑似乱数整数を返すC関数`rand()`のバインディングは次のようになります。

```c
#include <stdlib.h> /* rand()の定義を読み込む */

#include <ruby.h> /* RubyのC APIを読み込む */

static VALUE /* VALUEはCの世界でRubyのオブジェクトを表す型 */
rb_c_rand(VALUE self)
{
  /* INT2NUM()はCのintからRubyのIntegerオブジェクトを作る */
  return INT2NUM(rand());
}

void
Init_c_rand(void)
{
  /* トップレベルでdef c_rand ... endするのと同じ */
  rb_define_global_function("c_rand", rb_c_rand, 0);
}
```

「Rubyが提供するC APIを利用して、Cでバインディングを実装する」方法のメリットは次の通りです。

  * RubyのC APIは使いやすいので慣れてくれば技術的に難しいところはあまりない

  * 他の方法に比べてオーバーヘッドが少ないので、最も高速な実装になりやすい

一方、デメリットは次の通りです。

  * 各機能をそれぞれ実装することに加え、Cで実装するため、手間がかかる

### Fiddleを利用して、Rubyでバインディングを実装する

次は、「Fiddleを利用して、Rubyでバインディングを実装する」方法について説明します。

RubyにはFiddleという標準ライブラリーがあります。これは[libffi][libffi]という「実行時に任意のCの関数を呼び出す機能」を提供するライブラリーのバインディングです。つまり、Fiddleを使うと、Rubyから（Cのコードを書かずに）任意のCの関数を呼び出せるようになります。なお、[ffi gem][ffi-gem]もFiddleと同様にlibffiのバインディングです。ffi gemを使ってもメリット・デメリットはあまり変わりません。

たとえば、疑似乱数整数を返すC関数`rand()`のバインディングは次のようになります。

```ruby
require "fiddle/import"

module STDLib
  # このモジュールの中でFiddleを使う
  extend Fiddle::Importer
  # rand()を定義しているCで実装されたライブラリーを読み込む
  dlload "libc.so.6"
  # rand()を定義をパースしてRubyから呼び出せるようにする
  extern "int rand(void)"
end

# Cで実装された関数を呼び出す
p STDLib.rand
```

一見、Cのことを知らなくてもRubyだけ知っていれば使えるんじゃないかという気持ちになりますが、そんなことはありません。むしろ、「Rubyが提供するC APIを利用して、Cでバインディングを実装する」方法よりもCのことを知らないと困ることが多いです。

たとえば、`dlload`に指定するライブラリー名で困ることがあります。普通にCのライブラリーとしてリンクして使うときは、ライブラリー名やライブラリーの場所の検出を支援するツールを使えます。たとえば、[pkg-config][pkg-config]がそのようなツールです。このようなツールを使えば具体的なライブラリー名やパスは環境に合わせて自動で見つかるので気にする必要がありません。しかし、Fiddleを使うときは自分でそのあたりのことをケアしないといけないため、pkg-configがやってくれるようなことをRubyで自分で実装する必要があります。

また、構造体や関数の定義で困ることもあります。Cでバインディングを書くときは`#include`するだけでよかったですが、Fiddleを使う場合は`#include`できないので自分でFiddleに構造体や関数の定義を伝える必要があります。アラインメントのことを気にしたり、バージョンによって定義が違う場合のケアをするなど、Cでバインディングを書くときよりもCの知識が必要になります。

なお、C++で実装されたライブラリーにはこの方法を使えません。コンパイラーによって関数やクラスなどの名前をmangleする方法が違ったり、例外やテンプレートなどC++特有の機能があるからです。

「Fiddleを利用して、Rubyでバインディングを実装する」方法のメリットは次の通りです。

  * 単純な機能であればCの知識があまりなくても実装できる

  * コンパイルする必要がない

一方、デメリットは次の通りです。

  * Cで実装されたライブラリーを見つける処理の実装が面倒

  * 少し込み入ったことをしようとするとCの詳しい知識が必要

  * 対応したいCの関数定義を列挙するのが面倒

    * Cのヘッダーファイルをパースする機能を実現（Rubyで実装したり既存のCコンパイラーを利用したり）して自動化しようとする試みはあります。

  * C++で実装されたライブラリーには使えない

  * libffiのオーバーヘッドがそれなりにあるのでCで実装する場合に比べて遅くなる

  * Cの関数をRubyで利用できるようにするだけなので、Rubyから使いやすいAPIをRubyで作る必要がある

### SWIGを利用して、Cで実装されたバインディングを自動生成する

次は、「SWIGを利用して、Cで実装されたバインディングを実装する」方法について説明します。

SWIGはCのヘッダーファイルをパースして関数定義や`enum`などを抽出して「Rubyが提供するC APIを利用して、バインディングを実装したCのコード」を生成します。Fiddleを使う方法では自分で関数を列挙しなければいけませんでしたが、SWIGではそれをしなくてもよいです。

SWIGが生成するのはCのコードなので、コンパイルしないと使えません。Fiddleを使った方法ではコンパイルせずに使えました。

たとえば、次のような`User`オブジェクトにあるとします。

```c
/* user.h */
#pragma once

typedef struct User User;

User *user_new(const char *name, int age);
void user_free(User *user);

const char *user_get_name(User *user);
int user_get_age(User *user);
```

この`User`ライブラリーのバインディングを作るSWIGの入力ファイルは次のようになります。


```swig
// user.i

%module user

%{
#include "user.h"
%}

%include "user.h"
```

次のコマンドを実行すると`user_wrap.c`にCのコードを生成します。

```console
% swig -ruby user.i
```

あとは通常の拡張ライブラリー（RubyのC APIを使ってCで実装したRubyのライブラリー）と同様にビルドします。

このバインディングは次のように使います。

```ruby
require_relative "user.so"

user = User.user_new("Alice", 29)
p User.user_get_name(user) # -> "Alice"
p User.user_get_age(user)  # -> 29
User.user_free(user)
```

このように、SWIGが自動で抽出した関数の名前はCのまま`user_new`や`user_get_name`のようになるので、Rubyからは使いやすくありません。

RubyらしいAPIにするには次のどちらかのやり方があります。

  * SWIGのソースでカスタマイズ

  * RubyでSWIGが生成したAPIをラップ

SWIGで生成したバインディングは手で書いたバインディングよりもオーバーヘッドが大きいことが多いです。といってもlibffiよりは小さいです。

「SWIGを利用して、Cで実装されたバインディングを実装する」方法のメリットは次の通りです。

  * 自動でバインディング対象の関数や`enum`を抽出してくれるのですぐに網羅的に機能を使える

  * libffiよりはオーバーヘッドが小さい

一方、デメリットは次の通りです。

  * 自動抽出で定義されたAPIは使いにくいので、結局人手の作業が必要になる

  * CだけでなくSWIGの知識が必要

### GObject Introspectionを利用して、実行時にバインディングを自動生成する

最後は、「GObject Introspectionを利用して、実行時にバインディングを自動生成する」方法について説明します。

Fiddleを使った方法で関数を自分で列挙しなければいけないのは、Cのライブラリーがどのような関数を提供しているかを自動抽出できないからです。SWIGを使った方法で関数を自動抽出できるのは、ヘッダーファイルから必要な情報を取得しているからです。ライブラリーから直接情報を取得しているわけではありません。

GObject Introspectionを使うと、提供している関数の情報をライブラリー側が提供するようになります。ヘッダーファイルでも提供しているとは言えますが、GObject Introspectionはもっと再利用しやすい形で提供しています。たとえば、`const char *user_get_name(User *user)`という文字列をパースしなくても必要な情報を取得できます。

ヘッダーファイルをパースする方法では、ビルドオプションが違うと違う結果になることがありますが、GObject Introspectionの方法ではそのようなことはありません。

GObject Introspectionのアプローチではプログラムの実行時に関数の情報を使うことも簡単です。GObject Introspectionを使うとlibffiを使って実行時にバインディングを作ることができます。
（SWIGのように実行時ではなくビルド時にバインディングを自動生成することもできます。）

以下に各アプローチの違いを図示しました。

```text
Fiddleのアプローチ：

|<- Cのライブラリーの範囲 ->|    |<- Rubyの範囲 ---------------->|
+--------------+                +-------+
|Cのライブラリー| <------------- |libffi | <- 関数の情報 - 開発者
+--------------+                +-------+

SWIGのアプローチ：

|<- Cのライブラリーの範囲 ->|    |<- Rubyの範囲 ------->|
+--------------+                +---------------------+
|Cのライブラリー| <------------  |自動生成したCのコード |
+--------------+                +---------------------+
                                                     ^
+---------------+                                    |
|ヘッダーファイル| -------------- SWIG - 関数の情報 --+
+---------------+

GObject Introspctionのアプローチ：

|<- Cのライブラリーの範囲 ->|    |<- Rubyの範囲 ---------------->|
+--------------+                +------------------------------+
|Cのライブラリー| <------------- |実行時にlibffiを使ってアクセス |
+--------------+                +------------------------------+
                                     ^
+---------------+                    |
|.typelibファイル| ------------------+
+---------------+
  関数の情報
```

GObject Introspectionが提供する関数の情報はオブジェクト指向な情報も含んでいるのでRubyから自然に使えます。たとえば、SWIGで使った例のようなライブラリーの場合は次のように使えるAPIを実行時に自動で生成します。ビルドする必要はありません。

```ruby
user = User.new("Alice", 29)
p user.name # -> "Alice"
p user.age  # -> 29
```

「GObject Introspectionを利用して、実行時にバインディングを自動生成する」方法のメリットは次の通りです。

  * 実行時にバインディングを自動生成できる

  * 使いやすいAPIを自動生成できる

  * ライブラリー側が持っている関数の情報を提供するので、ライブラリーを更新するだけで、バインディング側を更新しなくても最新の機能を使える

  * Rubyではデータをゼロコピーで再利用するための便利な仕組みを実装済み

一方、デメリットは次の通りです。

  * Fiddleよりもオーバーヘッドが大きい

  * CのライブラリーがGObject Introspectionに対応していない場合はGObject Introspectionに対応したラッパーCライブラリーを開発しないといけない

  * CだけでなくGObject（Cでオブジェクト指向な機能を実現するためのライブラリー）の知識が必要

この文書では以下の点がデータサイエンスの分野で重要なためGObject Introspectionを使った方法を説明します。

  * 使いやすいAPIを自動生成できる

  * データをゼロコピーで再利用しやすい

## GObject Introspection対応ライブラリーの開発方法

TODO

[gobject-introspection]:https://wiki.gnome.org/Projects/GObjectIntrospection

[opencv]:https://opencv.org/

[SWIG]:http://www.swig.org/

[Fiddle]:https://docs.ruby-lang.org/ja/latest/library/fiddle.html

[libffi]:https://sourceware.org/libffi/

[ffi-gem]:https://github.com/ffi/ffi/wiki

[pkg-config]:https://www.freedesktop.org/wiki/Software/pkg-config/
